# ggplot 24h by weekday
d.weekday <- d.total %>% group_by(weekday, hour) %>%
summarise(rental = round(mean(rental_count))) %>%
rename(category = weekday)
show_24h_category_statistics_plot(d.weekday, "24h Rental by Weekday", "Weekday")
# Chunk 8
ggplot(d.total, aes(x=month, y=rental_count, color=month)) +
geom_boxplot(data=d.total, aes(group=month)) +
ggtitle("Hourly rental distribution on months") + ylab("rentals / hour")
# Chunk 9
# ggplot 24h by weather types
d.wtype <- d.total %>% group_by(type, hour) %>%
summarise(rental = round(mean(rental_count))) %>%
rename(category = type)
show_24h_category_statistics_plot(d.wtype, "24h Rental by Weather Type", "Weather Type")
# Chunk 10
## the rental of the weekdays with an influence of the weather
ggplot(d.total, aes(x=weekday, y=rental_count)) +
geom_point() +
ylab("rentals / hour") +
facet_grid(. ~ type) +
ggpubr::rotate_x_text()
# Chunk 11
## correlation plot
d.total[,5:10] %>% cor() %>% corrplot(method = 'color', addCoef.col="black")
# Chunk 12
## split a train and a test set
set.seed(1)
d.split <- sample.split(d.total, SplitRatio = 0.7)
d.train <- subset(d.total, subset = d.split)
d.test <- subset(d.total, subset = !d.split)
# Poisson model with all possible predictors
pm.fit <- glm(rental_count ~ . - rental_count - tripduration - date,
family="poisson", data=d.train)
# predict model on test data
pm.pred <- predict(pm.fit, newdata = d.test, type="response")
# compute MSE
pm.mse <- mean((d.test$rental_count - pm.pred)^2)
cat("Complex Poisson model MSE: ", pm.mse)
# Chunk 13
# residual
resid_values <- resid(pm.fit)
cat("Residual legnth: ", length(resid_values), "\n")
cat("Residual header: ", head(resid_values), "\n")
# residual analysis plots
par(mfrow=c(2,2))
plot(pm.fit)
# Chunk 14
# ggplot predicted values of hourly rental for different weather types
p1 <- ggplot(d.test, aes(x=hour, y=pm.pred, color=type)) +
geom_point(data=d.test, aes(group=type)) +
ggtitle("Prediction values") + ylab("predicted rentals / hour") +
scale_color_hue("Weather Type", breaks=levels(d.test$type))
# ggplot true values of hourly rental for different weather types
p2 <- ggplot(d.test, aes(x=hour, y=rental_count, color=type)) +
geom_point(data=d.test, aes(group=type)) +
ggtitle("Real values") + ylab("rentals / hour") +
scale_color_hue("Weather Type", breaks=levels(d.test$type))
figure <- ggarrange(p1, p2, ncol=2, common.legend = TRUE, legend="bottom")
annotate_figure(figure, top=text_grob("Hour & Weather on Rental - Complex Poisson Model",
size = 14))
# Chunk 15
## check normal distribution for linear model fitting
par(mfrow=c(1, 2))
hist(d.total$rental_count, main = "Rental Count Histogram")
hist(log(d.total$rental_count), main = "Rental Count Log Histogram")
# Chunk 16
set.seed(1)
cv.error.10 <- rep(0, 10)
for (i in 1:10) {
glm.fit <- glm(log(rental_count) ~ type + month + weekday + hour + humidity * dewpoint +
poly(windspeed, degree=i) + poly(temperature, degree=i), data=d.train)
cv.error.10[i] <- cv.glm(d.train, glm.fit, K=10)$delta[1]
}
best.level <- which.min(cv.error.10)
cat("Index of model with least error rate: ", best.level, "\n")
cat("Cross validation error of different polynominal linear models:\n", cv.error.10, "\n")
glm.fit.best <- glm(log(rental_count) ~ type + month + weekday + hour +
humidity * dewpoint +
poly(windspeed, degree = best.level) +
poly(temperature, degree = best.level),
data=d.train)
# predict model on test data
glm.pred <- predict(glm.fit.best, newdata = d.test)
# convert log value to normal value via exponential
glm.pred <- exp(glm.pred)
# compute MSE
glm.mse <- mean((d.test$rental_count - glm.pred)^2)
cat("GLM polynomial model MSE: ", glm.mse)
# Chunk 17
# residual
resid_values <- resid(glm.fit.best)
cat("Residual length: ", length(resid_values))
cat("Residual header: ", head(resid_values))
# plot
par(mfrow=c(2,2))
plot(glm.fit.best)
# Chunk 18
# ggplot predicted values of hourly rental for different weather types
p1 <- ggplot(d.test, aes(x=hour, y=glm.pred, color=type)) +
geom_point(data=d.test, aes(group=type)) +
ggtitle("Prediction values") + ylab("predicted rentals / hour") +
scale_color_hue("Weather Type", breaks=levels(d.test$type))
# ggplot true values of hourly rental for different weather types
p2 <- ggplot(d.test, aes(x=hour, y=rental_count, color=type)) +
geom_point(data=d.test, aes(group=type)) +
ggtitle("Real values") + ylab("rentals / hour") +
scale_color_hue("Weather Type", breaks=levels(d.test$type))
figure <- ggarrange(p1, p2, ncol=2, common.legend = TRUE, legend="bottom")
annotate_figure(figure, top = text_grob("Hour & Weather on Rental - Polynomial Linear Model",
size = 14))
# Chunk 19
set.seed(1)
rf.fit <- randomForest(rental_count ~ . - rental_count - tripduration - date,
data = d.train, mtry=3, ntree=50, importance=TRUE)
rf.pred <- predict(rf.fit, d.test)
rf.mse <- mean((rf.pred - d.test$rental_count)^2)
cat("Randomforest mode MSE: ", rf.mse)
importance(rf.fit)
varImpPlot(rf.fit, main = "Randonforest Feature Importance")
# Chunk 20
# plot randomforest model fit
plot(rf.fit, main="Error rate vs. number of tree grown")
# ggplot predicted values of hourly rental for different weather types
p1 <- ggplot(d.test, aes(x=hour, y=rf.pred, color=type)) +
geom_point(data=d.test, aes(group=type)) +
ggtitle("Prediction values") + ylab("predicted rentals / hour") +
scale_color_hue("Weather Type", breaks=levels(d.test$type))
# ggplot true values of hourly rental for different weather types
p2 <- ggplot(d.test, aes(x=hour, y=rental_count, color=type)) +
geom_point(data=d.test, aes(group=type)) +
ggtitle("Real values") + ylab("rentals / hour") +
scale_color_hue("Weather Type", breaks=levels(d.test$type))
figure <- ggarrange(p1, p2, ncol=2, common.legend = TRUE, legend="bottom")
annotate_figure(figure, top = text_grob("Hour & Weather on Rental - Randomforest Model",
size = 14))
# Chunk 21
# Chunk 22
d.total2 <- readRDS("./data/d.bike_weather.rds")
# get background map
min_lon <- min(d.total2$start_station_longitude, d.total2$end_station_longitude)
max_lon <- max(d.total2$start_station_longitude, d.total2$end_station_longitude)
min_lat <- min(d.total2$start_station_latitude, d.total2$end_station_latitude)
max_lat <- max(d.total2$start_station_latitude, d.total2$end_station_latitude)
mad_map <- (map <- get_map(c(left = min_lon, bottom = min_lat,
right = max_lon, top = max_lat)))
# take a random sample of size 1%
d.total2.sample = d.total2[
base::sample(x=1:nrow(d.total2), round(nrow(d.total2)*1/100)), ]
# Chunk 23
ggmap(mad_map) +
geom_leg(
data=d.total2.sample,
# color = factor(gender),
alpha=0.1,
aes(
color = age,
x = start_station_longitude,
y = start_station_latitude,
xend = end_station_longitude,
yend = end_station_latitude
)
)+
labs(x="",y="") +
facet_grid(month ~ gender) +
theme(
axis.title.x=element_blank(),
axis.text.x=element_blank(),
axis.ticks.x=element_blank(),
axis.title.y=element_blank(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank()
) +
scale_color_viridis(option = "magma")
ggsave("map_age_gender_month.pdf", device = "pdf")
# remove all objects loaded and clear memory
rm(list = ls(all.names = TRUE))
gc()
library(checkpoint)
#checkpoint(snapshotDate = "2099-12-29")
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(echo=TRUE)
set.seed(19)
ggmap(mad_map) +
geom_leg(
data=d.total2.sample,
# color = factor(gender),
alpha=0.1,
aes(
color = age,
x = start_station_longitude,
y = start_station_latitude,
xend = end_station_longitude,
yend = end_station_latitude
)
)+
labs(x="",y="") +
facet_grid(. ~ gender) +
theme(
axis.title.x=element_blank(),
axis.text.x=element_blank(),
axis.ticks.x=element_blank(),
axis.title.y=element_blank(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank()
) +
scale_color_viridis(option = "magma")
ggsave("map_age_gender_month.pdf", device = "pdf")
# Chunk 1: setup
# remove all objects loaded and clear memory
rm(list = ls(all.names = TRUE))
gc()
library(checkpoint)
#checkpoint(snapshotDate = "2099-12-29")
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(echo=TRUE)
set.seed(19)
# Chunk 2: importLibraries
list.of.packages <- c("installr", "Hmisc", "ggmap", "tidyverse", "tidyr", "corrplot",
"viridis", "leaflet", "lubridate", "checkpoint", "zoo", "caTools",
"randomForest", "boot", "ggpubr")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
for (p in list.of.packages){
library(p, character.only = TRUE)
}
# Chunk 3: userFunctions
## user defined functions and constants ##
## holidays in New York City in 2016
public_holidays <- c("2016-01-01", "2016-01-18", "2016-02-12", "2016-02-15",
"2016-05-30", "2016-07-04", "2016-09-05", "2016-10-10",
"2016-11-11", "2016-11-24", "2016-12-26")
## plot bike rental count over 24 hours for different category groups
## @param d.data: expects properties: category, hour, rental
## @param title: the title of the plot
## @param category_name: the category group name used as the legend's name in the plot
show_24h_category_statistics_plot <- function (d.data, title, category_name) {
ggplot(d.data, aes(x=hour, y=rental, color=category)) +
geom_point(data=d.data, aes(group=category)) +
geom_line(data=d.data, aes(group=category)) +
ggtitle(title) + ylab("rentals / hour") +
scale_color_hue(category_name, breaks=levels(d.data$category))
}
# Chunk 4
## read bike and weather data sets
d.bike <- readRDS("./data/d.bike.rds")
colnames(d.bike)
dim(d.bike)
d.weather <- readRDS("./data/d.weather.rds")
colnames(d.weather)
dim(d.weather)
## merge both bike and weather data for analysis
d.total <- merge(d.bike, d.weather, all.x=TRUE)
# order by data and hour
d.total <- d.total[with(d.total, order(date, hour)),]
d.total$weekday <- factor(d.total$weekday,
levels = c("Monday", "Tuesday", "Wednesday",
"Thursday", "Friday", "Saturday", "Sunday"))
# reset row index to normal
rownames(d.total) <- NULL
# Chunk 5
## public holiday analysis ##
## rental statistics in weekdays
rentweekday <- d.total %>%
group_by(weekday) %>%
summarise(rental=round(sum(rental_count)/52),
tripduration=round(sum(tripduration)/52)) %>% # 52 weeks of a year
arrange(weekday)
rentweekday
## rentals statistics in public holidays
rentholiday <- d.total %>%
filter(as.character(date) %in% public_holidays) %>%
group_by(date) %>%
summarise(rental=sum(rental_count),
tripduration=sum(tripduration)) %>%
arrange(date)
rentholiday
## As we can see, the rental in public holidays are different from the weekdays and
## among themselves. Public holiday data can be used for the model fitting if we
## would like to predict for a different year.
## However, only data from 2016 are used for both the train and test data sets.
## Droping the public holiday data would reduce the variance in the model.
## remove public holiday dataset
d.total <- filter(d.total, !as.character(date) %in% public_holidays)
# Chunk 6
## save processed data to file
saveRDS(d.total, file = "./data/d.total.rds")
# Chunk 7
# ggplot 24h by weekday
d.weekday <- d.total %>% group_by(weekday, hour) %>%
summarise(rental = round(mean(rental_count))) %>%
rename(category = weekday)
show_24h_category_statistics_plot(d.weekday, "24h Rental by Weekday", "Weekday")
# Chunk 8
ggplot(d.total, aes(x=month, y=rental_count, color=month)) +
geom_boxplot(data=d.total, aes(group=month)) +
ggtitle("Hourly rental distribution on months") + ylab("rentals / hour")
# Chunk 9
# ggplot 24h by weather types
d.wtype <- d.total %>% group_by(type, hour) %>%
summarise(rental = round(mean(rental_count))) %>%
rename(category = type)
show_24h_category_statistics_plot(d.wtype, "24h Rental by Weather Type", "Weather Type")
# Chunk 10
## the rental of the weekdays with an influence of the weather
ggplot(d.total, aes(x=weekday, y=rental_count)) +
geom_point() +
ylab("rentals / hour") +
facet_grid(. ~ type) +
ggpubr::rotate_x_text()
# Chunk 11
## correlation plot
d.total[,5:10] %>% cor() %>% corrplot(method = 'color', addCoef.col="black")
# Chunk 12
## split a train and a test set
set.seed(1)
d.split <- sample.split(d.total, SplitRatio = 0.7)
d.train <- subset(d.total, subset = d.split)
d.test <- subset(d.total, subset = !d.split)
# Poisson model with all possible predictors
pm.fit <- glm(rental_count ~ . - rental_count - tripduration - date,
family="poisson", data=d.train)
# predict model on test data
pm.pred <- predict(pm.fit, newdata = d.test, type="response")
# compute MSE
pm.mse <- mean((d.test$rental_count - pm.pred)^2)
cat("Complex Poisson model MSE: ", pm.mse)
# Chunk 13
# residual
resid_values <- resid(pm.fit)
cat("Residual legnth: ", length(resid_values), "\n")
cat("Residual header: ", head(resid_values), "\n")
# residual analysis plots
par(mfrow=c(2,2))
plot(pm.fit)
# Chunk 14
# ggplot predicted values of hourly rental for different weather types
p1 <- ggplot(d.test, aes(x=hour, y=pm.pred, color=type)) +
geom_point(data=d.test, aes(group=type)) +
ggtitle("Prediction values") + ylab("predicted rentals / hour") +
scale_color_hue("Weather Type", breaks=levels(d.test$type))
# ggplot true values of hourly rental for different weather types
p2 <- ggplot(d.test, aes(x=hour, y=rental_count, color=type)) +
geom_point(data=d.test, aes(group=type)) +
ggtitle("Real values") + ylab("rentals / hour") +
scale_color_hue("Weather Type", breaks=levels(d.test$type))
figure <- ggarrange(p1, p2, ncol=2, common.legend = TRUE, legend="bottom")
annotate_figure(figure, top=text_grob("Hour & Weather on Rental - Complex Poisson Model",
size = 14))
# Chunk 15
## check normal distribution for linear model fitting
par(mfrow=c(1, 2))
hist(d.total$rental_count, main = "Rental Count Histogram")
hist(log(d.total$rental_count), main = "Rental Count Log Histogram")
# Chunk 16
set.seed(1)
cv.error.10 <- rep(0, 10)
for (i in 1:10) {
glm.fit <- glm(log(rental_count) ~ type + month + weekday + hour + humidity * dewpoint +
poly(windspeed, degree=i) + poly(temperature, degree=i), data=d.train)
cv.error.10[i] <- cv.glm(d.train, glm.fit, K=10)$delta[1]
}
best.level <- which.min(cv.error.10)
cat("Index of model with least error rate: ", best.level, "\n")
cat("Cross validation error of different polynominal linear models:\n", cv.error.10, "\n")
glm.fit.best <- glm(log(rental_count) ~ type + month + weekday + hour +
humidity * dewpoint +
poly(windspeed, degree = best.level) +
poly(temperature, degree = best.level),
data=d.train)
# predict model on test data
glm.pred <- predict(glm.fit.best, newdata = d.test)
# convert log value to normal value via exponential
glm.pred <- exp(glm.pred)
# compute MSE
glm.mse <- mean((d.test$rental_count - glm.pred)^2)
cat("GLM polynomial model MSE: ", glm.mse)
# Chunk 17
# residual
resid_values <- resid(glm.fit.best)
cat("Residual length: ", length(resid_values))
cat("Residual header: ", head(resid_values))
# plot
par(mfrow=c(2,2))
plot(glm.fit.best)
# Chunk 18
# ggplot predicted values of hourly rental for different weather types
p1 <- ggplot(d.test, aes(x=hour, y=glm.pred, color=type)) +
geom_point(data=d.test, aes(group=type)) +
ggtitle("Prediction values") + ylab("predicted rentals / hour") +
scale_color_hue("Weather Type", breaks=levels(d.test$type))
# ggplot true values of hourly rental for different weather types
p2 <- ggplot(d.test, aes(x=hour, y=rental_count, color=type)) +
geom_point(data=d.test, aes(group=type)) +
ggtitle("Real values") + ylab("rentals / hour") +
scale_color_hue("Weather Type", breaks=levels(d.test$type))
figure <- ggarrange(p1, p2, ncol=2, common.legend = TRUE, legend="bottom")
annotate_figure(figure, top = text_grob("Hour & Weather on Rental - Polynomial Linear Model",
size = 14))
# Chunk 19
set.seed(1)
rf.fit <- randomForest(rental_count ~ . - rental_count - tripduration - date,
data = d.train, mtry=3, ntree=50, importance=TRUE)
rf.pred <- predict(rf.fit, d.test)
rf.mse <- mean((rf.pred - d.test$rental_count)^2)
cat("Randomforest mode MSE: ", rf.mse)
importance(rf.fit)
varImpPlot(rf.fit, main = "Randonforest Feature Importance")
# Chunk 20
# plot randomforest model fit
plot(rf.fit, main="Error rate vs. number of tree grown")
# ggplot predicted values of hourly rental for different weather types
p1 <- ggplot(d.test, aes(x=hour, y=rf.pred, color=type)) +
geom_point(data=d.test, aes(group=type)) +
ggtitle("Prediction values") + ylab("predicted rentals / hour") +
scale_color_hue("Weather Type", breaks=levels(d.test$type))
# ggplot true values of hourly rental for different weather types
p2 <- ggplot(d.test, aes(x=hour, y=rental_count, color=type)) +
geom_point(data=d.test, aes(group=type)) +
ggtitle("Real values") + ylab("rentals / hour") +
scale_color_hue("Weather Type", breaks=levels(d.test$type))
figure <- ggarrange(p1, p2, ncol=2, common.legend = TRUE, legend="bottom")
annotate_figure(figure, top = text_grob("Hour & Weather on Rental - Randomforest Model",
size = 14))
# Chunk 21
# Chunk 22
d.total2 <- readRDS("./data/d.bike_weather.rds")
# get background map
min_lon <- min(d.total2$start_station_longitude, d.total2$end_station_longitude)
max_lon <- max(d.total2$start_station_longitude, d.total2$end_station_longitude)
min_lat <- min(d.total2$start_station_latitude, d.total2$end_station_latitude)
max_lat <- max(d.total2$start_station_latitude, d.total2$end_station_latitude)
mad_map <- (map <- get_map(c(left = min_lon, bottom = min_lat,
right = max_lon, top = max_lat)))
# take a random sample of size 1%
d.total2.sample = d.total2[
base::sample(x=1:nrow(d.total2), round(nrow(d.total2)*1/100)), ]
ggmap(mad_map) +
geom_leg(
data=d.total2.sample,
# color = factor(gender),
alpha=0.1,
aes(
color = age,
x = start_station_longitude,
y = start_station_latitude,
xend = end_station_longitude,
yend = end_station_latitude
)
)+
labs(x="",y="") +
facet_grid(. ~ gender) +
theme(
axis.title.x=element_blank(),
axis.text.x=element_blank(),
axis.ticks.x=element_blank(),
axis.title.y=element_blank(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank()
) +
scale_color_viridis(option = "magma")
ggsave("map_age_gender_month.pdf", device = "pdf")
ggmap(mad_map) +
geom_leg(
data=d.total2.sample,
# color = factor(gender),
alpha=0.1,
aes(
color = age,
x = start_station_longitude,
y = start_station_latitude,
xend = end_station_longitude,
yend = end_station_latitude
)
)+
labs(x="",y="") +
facet_grid(. ~ month) +
theme(
axis.title.x=element_blank(),
axis.text.x=element_blank(),
axis.ticks.x=element_blank(),
axis.title.y=element_blank(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank()
) +
scale_color_viridis(option = "magma")
ggsave("map_age_gender_month.pdf", device = "pdf")
ggmap(mad_map) +
geom_leg(
data=d.total2.sample,
# color = factor(gender),
alpha=0.1,
aes(
color = age,
x = start_station_longitude,
y = start_station_latitude,
xend = end_station_longitude,
yend = end_station_latitude
)
)+
labs(x="",y="") +
facet_grid(month ~ .) +
theme(
axis.title.x=element_blank(),
axis.text.x=element_blank(),
axis.ticks.x=element_blank(),
axis.title.y=element_blank(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank()
) +
scale_color_viridis(option = "magma")
ggsave("map_age_gender_month.pdf", device = "pdf")
